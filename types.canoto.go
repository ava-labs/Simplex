// Code generated by canoto. DO NOT EDIT.
// versions:
// 	canoto v0.10.0
// source: types.go

package simplex

import (
	"io"
	"sync/atomic"
	"unicode/utf8"

	"github.com/StephenButtolph/canoto"
)

// Ensure that unused imports do not error
var (
	_ atomic.Int64

	_ = io.ErrUnexpectedEOF
	_ = utf8.ValidString
)

const (
	canoto__Record__Block__tag        = "\x0a" // canoto.Tag(1, canoto.Len)
	canoto__Record__Notarization__tag = "\x12" // canoto.Tag(2, canoto.Len)
	canoto__Record__Finalization__tag = "\x1a" // canoto.Tag(3, canoto.Len)
)

type canotoData_Record struct {
	size int

	recordOneOf uint32
}

// MakeCanoto creates a new empty value.
func (*Record) MakeCanoto() *Record {
	return new(Record)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// OneOf fields are cached during the unmarshaling process.
//
// The struct is not cleared before unmarshaling, any fields not present in the
// bytes will retain their previous values. If a OneOf field was previously
// cached as being set, attempting to unmarshal that OneOf again will return
// canoto.ErrDuplicateOneOf.
func (c *Record) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// OneOf fields are cached during the unmarshaling process.
//
// The struct is not cleared before unmarshaling, any fields not present in the
// bytes will retain their previous values. If a OneOf field was previously
// cached as being set, attempting to unmarshal that OneOf again will return
// canoto.ErrDuplicateOneOf.
//
// This function enables configuration of reader options.
func (c *Record) UnmarshalCanotoFrom(r canoto.Reader) error {
	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}
			if c.canotoData.recordOneOf != 0 {
				return canoto.ErrDuplicateOneOf
			}
			c.canotoData.recordOneOf = 1

			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			err := canoto.ReadBytes(&r, &msgBytes)
			r.Unsafe = originalUnsafe
			if err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}

			remainingBytes := r.B
			r.B = msgBytes
			c.Block = canoto.MakePointer(c.Block)
			err = (c.Block).UnmarshalCanotoFrom(r)
			r.B = remainingBytes
			if err != nil {
				return err
			}
		case 2:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}
			if c.canotoData.recordOneOf != 0 {
				return canoto.ErrDuplicateOneOf
			}
			c.canotoData.recordOneOf = 2

			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			err := canoto.ReadBytes(&r, &msgBytes)
			r.Unsafe = originalUnsafe
			if err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}

			remainingBytes := r.B
			r.B = msgBytes
			c.Notarization = canoto.MakePointer(c.Notarization)
			err = (c.Notarization).UnmarshalCanotoFrom(r)
			r.B = remainingBytes
			if err != nil {
				return err
			}
		case 3:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}
			if c.canotoData.recordOneOf != 0 {
				return canoto.ErrDuplicateOneOf
			}
			c.canotoData.recordOneOf = 3

			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			err := canoto.ReadBytes(&r, &msgBytes)
			r.Unsafe = originalUnsafe
			if err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}

			remainingBytes := r.B
			r.B = msgBytes
			c.Finalization = canoto.MakePointer(c.Finalization)
			err = (c.Finalization).UnmarshalCanotoFrom(r)
			r.B = remainingBytes
			if err != nil {
				return err
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *Record) ValidCanoto() bool {
	if c == nil {
		return true
	}
	var (
		recordOneOf uint32
	)
	if c.Block != nil {
		(c.Block).CalculateCanotoCache()
		if (c.Block).CachedCanotoSize() != 0 {
			if recordOneOf != 0 {
				return false
			}
			recordOneOf = 1
		}
	}
	if c.Notarization != nil {
		(c.Notarization).CalculateCanotoCache()
		if (c.Notarization).CachedCanotoSize() != 0 {
			if recordOneOf != 0 {
				return false
			}
			recordOneOf = 2
		}
	}
	if c.Finalization != nil {
		(c.Finalization).CalculateCanotoCache()
		if (c.Finalization).CachedCanotoSize() != 0 {
			if recordOneOf != 0 {
				return false
			}
			recordOneOf = 3
		}
	}
	if c.Block != nil && !(c.Block).ValidCanoto() {
		return false
	}
	if c.Notarization != nil && !(c.Notarization).ValidCanoto() {
		return false
	}
	if c.Finalization != nil && !(c.Finalization).ValidCanoto() {
		return false
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to call this function concurrently.
func (c *Record) CalculateCanotoCache() {
	if c == nil {
		return
	}
	c.canotoData.recordOneOf = 0
	c.canotoData.size = 0
	if c.Block != nil {
		(c.Block).CalculateCanotoCache()
		if fieldSize := (c.Block).CachedCanotoSize(); fieldSize != 0 {
			c.canotoData.size += len(canoto__Record__Block__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
		c.canotoData.recordOneOf = 1
		}
	}
	if c.Notarization != nil {
		(c.Notarization).CalculateCanotoCache()
		if fieldSize := (c.Notarization).CachedCanotoSize(); fieldSize != 0 {
			c.canotoData.size += len(canoto__Record__Notarization__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
		c.canotoData.recordOneOf = 2
		}
	}
	if c.Finalization != nil {
		(c.Finalization).CalculateCanotoCache()
		if fieldSize := (c.Finalization).CachedCanotoSize(); fieldSize != 0 {
			c.canotoData.size += len(canoto__Record__Finalization__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
		c.canotoData.recordOneOf = 3
		}
	}
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *Record) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return c.canotoData.size
}

// CachedWhichOneOfrecord returns the previously calculated field number used
// to represent record.
//
// This field is cached by UnmarshalCanoto, UnmarshalCanotoFrom, and
// CalculateCanotoCache.
//
// If the field has not yet been cached, it will return 0.
//
// If the struct has been modified since the field was last cached, the returned
// field number may be incorrect.
func (c *Record) CachedWhichOneOfrecord() uint32 {
	return c.canotoData.recordOneOf
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *Record) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *Record) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if c.Block != nil {
		if fieldSize := (c.Block).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__Record__Block__tag)
			canoto.AppendInt(&w, int64(fieldSize))
			w = (c.Block).MarshalCanotoInto(w)
		}
	}
	if c.Notarization != nil {
		if fieldSize := (c.Notarization).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__Record__Notarization__tag)
			canoto.AppendInt(&w, int64(fieldSize))
			w = (c.Notarization).MarshalCanotoInto(w)
		}
	}
	if c.Finalization != nil {
		if fieldSize := (c.Finalization).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__Record__Finalization__tag)
			canoto.AppendInt(&w, int64(fieldSize))
			w = (c.Finalization).MarshalCanotoInto(w)
		}
	}
	return w
}

const (
	canoto__QuorumRecord__Header__tag = "\x0a" // canoto.Tag(1, canoto.Len)
	canoto__QuorumRecord__QC__tag     = "\x12" // canoto.Tag(2, canoto.Len)
)

type canotoData_QuorumRecord struct {
	size int
}

// MakeCanoto creates a new empty value.
func (*QuorumRecord) MakeCanoto() *QuorumRecord {
	return new(QuorumRecord)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// OneOf fields are cached during the unmarshaling process.
//
// The struct is not cleared before unmarshaling, any fields not present in the
// bytes will retain their previous values. If a OneOf field was previously
// cached as being set, attempting to unmarshal that OneOf again will return
// canoto.ErrDuplicateOneOf.
func (c *QuorumRecord) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// OneOf fields are cached during the unmarshaling process.
//
// The struct is not cleared before unmarshaling, any fields not present in the
// bytes will retain their previous values. If a OneOf field was previously
// cached as being set, attempting to unmarshal that OneOf again will return
// canoto.ErrDuplicateOneOf.
//
// This function enables configuration of reader options.
func (c *QuorumRecord) UnmarshalCanotoFrom(r canoto.Reader) error {
	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			err := canoto.ReadBytes(&r, &msgBytes)
			r.Unsafe = originalUnsafe
			if err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}

			remainingBytes := r.B
			r.B = msgBytes
			err = (&c.Header).UnmarshalCanotoFrom(r)
			r.B = remainingBytes
			if err != nil {
				return err
			}
		case 2:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadBytes(&r, &c.QC); err != nil {
				return err
			}
			if len(c.QC) == 0 {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *QuorumRecord) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if !(&c.Header).ValidCanoto() {
		return false
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to call this function concurrently.
func (c *QuorumRecord) CalculateCanotoCache() {
	if c == nil {
		return
	}
	c.canotoData.size = 0
	(&c.Header).CalculateCanotoCache()
	if fieldSize := (&c.Header).CachedCanotoSize(); fieldSize != 0 {
		c.canotoData.size += len(canoto__QuorumRecord__Header__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
	if len(c.QC) != 0 {
		c.canotoData.size += len(canoto__QuorumRecord__QC__tag) + canoto.SizeBytes(c.QC)
	}
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *QuorumRecord) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return c.canotoData.size
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *QuorumRecord) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *QuorumRecord) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if fieldSize := (&c.Header).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__QuorumRecord__Header__tag)
		canoto.AppendInt(&w, int64(fieldSize))
		w = (&c.Header).MarshalCanotoInto(w)
	}
	if len(c.QC) != 0 {
		canoto.Append(&w, canoto__QuorumRecord__QC__tag)
		canoto.AppendBytes(&w, c.QC)
	}
	return w
}

const (
	canoto__BlockRecord__Header__tag  = "\x0a" // canoto.Tag(1, canoto.Len)
	canoto__BlockRecord__Payload__tag = "\x12" // canoto.Tag(2, canoto.Len)
)

type canotoData_BlockRecord struct {
	size int
}

// MakeCanoto creates a new empty value.
func (*BlockRecord) MakeCanoto() *BlockRecord {
	return new(BlockRecord)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// OneOf fields are cached during the unmarshaling process.
//
// The struct is not cleared before unmarshaling, any fields not present in the
// bytes will retain their previous values. If a OneOf field was previously
// cached as being set, attempting to unmarshal that OneOf again will return
// canoto.ErrDuplicateOneOf.
func (c *BlockRecord) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// OneOf fields are cached during the unmarshaling process.
//
// The struct is not cleared before unmarshaling, any fields not present in the
// bytes will retain their previous values. If a OneOf field was previously
// cached as being set, attempting to unmarshal that OneOf again will return
// canoto.ErrDuplicateOneOf.
//
// This function enables configuration of reader options.
func (c *BlockRecord) UnmarshalCanotoFrom(r canoto.Reader) error {
	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			err := canoto.ReadBytes(&r, &msgBytes)
			r.Unsafe = originalUnsafe
			if err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}

			remainingBytes := r.B
			r.B = msgBytes
			err = (&c.Header).UnmarshalCanotoFrom(r)
			r.B = remainingBytes
			if err != nil {
				return err
			}
		case 2:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadBytes(&r, &c.Payload); err != nil {
				return err
			}
			if len(c.Payload) == 0 {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *BlockRecord) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if !(&c.Header).ValidCanoto() {
		return false
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to call this function concurrently.
func (c *BlockRecord) CalculateCanotoCache() {
	if c == nil {
		return
	}
	c.canotoData.size = 0
	(&c.Header).CalculateCanotoCache()
	if fieldSize := (&c.Header).CachedCanotoSize(); fieldSize != 0 {
		c.canotoData.size += len(canoto__BlockRecord__Header__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
	if len(c.Payload) != 0 {
		c.canotoData.size += len(canoto__BlockRecord__Payload__tag) + canoto.SizeBytes(c.Payload)
	}
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *BlockRecord) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return c.canotoData.size
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *BlockRecord) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *BlockRecord) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if fieldSize := (&c.Header).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__BlockRecord__Header__tag)
		canoto.AppendInt(&w, int64(fieldSize))
		w = (&c.Header).MarshalCanotoInto(w)
	}
	if len(c.Payload) != 0 {
		canoto.Append(&w, canoto__BlockRecord__Payload__tag)
		canoto.AppendBytes(&w, c.Payload)
	}
	return w
}

const (
	canoto__Message__Proposal__tag     = "\x0a" // canoto.Tag(1, canoto.Len)
	canoto__Message__Vote__tag         = "\x12" // canoto.Tag(2, canoto.Len)
	canoto__Message__Notarization__tag = "\x1a" // canoto.Tag(3, canoto.Len)
	canoto__Message__Finalize__tag     = "\x22" // canoto.Tag(4, canoto.Len)
	canoto__Message__Finalization__tag = "\x2a" // canoto.Tag(5, canoto.Len)
)

type canotoData_Message struct {
	size int

	messageOneOf uint32
}

// MakeCanoto creates a new empty value.
func (*Message) MakeCanoto() *Message {
	return new(Message)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// OneOf fields are cached during the unmarshaling process.
//
// The struct is not cleared before unmarshaling, any fields not present in the
// bytes will retain their previous values. If a OneOf field was previously
// cached as being set, attempting to unmarshal that OneOf again will return
// canoto.ErrDuplicateOneOf.
func (c *Message) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// OneOf fields are cached during the unmarshaling process.
//
// The struct is not cleared before unmarshaling, any fields not present in the
// bytes will retain their previous values. If a OneOf field was previously
// cached as being set, attempting to unmarshal that OneOf again will return
// canoto.ErrDuplicateOneOf.
//
// This function enables configuration of reader options.
func (c *Message) UnmarshalCanotoFrom(r canoto.Reader) error {
	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}
			if c.canotoData.messageOneOf != 0 {
				return canoto.ErrDuplicateOneOf
			}
			c.canotoData.messageOneOf = 1

			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			err := canoto.ReadBytes(&r, &msgBytes)
			r.Unsafe = originalUnsafe
			if err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}

			remainingBytes := r.B
			r.B = msgBytes
			c.Proposal = canoto.MakePointer(c.Proposal)
			err = (c.Proposal).UnmarshalCanotoFrom(r)
			r.B = remainingBytes
			if err != nil {
				return err
			}
		case 2:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}
			if c.canotoData.messageOneOf != 0 {
				return canoto.ErrDuplicateOneOf
			}
			c.canotoData.messageOneOf = 2

			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			err := canoto.ReadBytes(&r, &msgBytes)
			r.Unsafe = originalUnsafe
			if err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}

			remainingBytes := r.B
			r.B = msgBytes
			c.Vote = canoto.MakePointer(c.Vote)
			err = (c.Vote).UnmarshalCanotoFrom(r)
			r.B = remainingBytes
			if err != nil {
				return err
			}
		case 3:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}
			if c.canotoData.messageOneOf != 0 {
				return canoto.ErrDuplicateOneOf
			}
			c.canotoData.messageOneOf = 3

			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			err := canoto.ReadBytes(&r, &msgBytes)
			r.Unsafe = originalUnsafe
			if err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}

			remainingBytes := r.B
			r.B = msgBytes
			c.Notarization = canoto.MakePointer(c.Notarization)
			err = (c.Notarization).UnmarshalCanotoFrom(r)
			r.B = remainingBytes
			if err != nil {
				return err
			}
		case 4:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}
			if c.canotoData.messageOneOf != 0 {
				return canoto.ErrDuplicateOneOf
			}
			c.canotoData.messageOneOf = 4

			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			err := canoto.ReadBytes(&r, &msgBytes)
			r.Unsafe = originalUnsafe
			if err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}

			remainingBytes := r.B
			r.B = msgBytes
			c.Finalize = canoto.MakePointer(c.Finalize)
			err = (c.Finalize).UnmarshalCanotoFrom(r)
			r.B = remainingBytes
			if err != nil {
				return err
			}
		case 5:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}
			if c.canotoData.messageOneOf != 0 {
				return canoto.ErrDuplicateOneOf
			}
			c.canotoData.messageOneOf = 5

			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			err := canoto.ReadBytes(&r, &msgBytes)
			r.Unsafe = originalUnsafe
			if err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}

			remainingBytes := r.B
			r.B = msgBytes
			c.Finalization = canoto.MakePointer(c.Finalization)
			err = (c.Finalization).UnmarshalCanotoFrom(r)
			r.B = remainingBytes
			if err != nil {
				return err
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *Message) ValidCanoto() bool {
	if c == nil {
		return true
	}
	var (
		messageOneOf uint32
	)
	if c.Proposal != nil {
		(c.Proposal).CalculateCanotoCache()
		if (c.Proposal).CachedCanotoSize() != 0 {
			if messageOneOf != 0 {
				return false
			}
			messageOneOf = 1
		}
	}
	if c.Vote != nil {
		(c.Vote).CalculateCanotoCache()
		if (c.Vote).CachedCanotoSize() != 0 {
			if messageOneOf != 0 {
				return false
			}
			messageOneOf = 2
		}
	}
	if c.Notarization != nil {
		(c.Notarization).CalculateCanotoCache()
		if (c.Notarization).CachedCanotoSize() != 0 {
			if messageOneOf != 0 {
				return false
			}
			messageOneOf = 3
		}
	}
	if c.Finalize != nil {
		(c.Finalize).CalculateCanotoCache()
		if (c.Finalize).CachedCanotoSize() != 0 {
			if messageOneOf != 0 {
				return false
			}
			messageOneOf = 4
		}
	}
	if c.Finalization != nil {
		(c.Finalization).CalculateCanotoCache()
		if (c.Finalization).CachedCanotoSize() != 0 {
			if messageOneOf != 0 {
				return false
			}
			messageOneOf = 5
		}
	}
	if c.Proposal != nil && !(c.Proposal).ValidCanoto() {
		return false
	}
	if c.Vote != nil && !(c.Vote).ValidCanoto() {
		return false
	}
	if c.Notarization != nil && !(c.Notarization).ValidCanoto() {
		return false
	}
	if c.Finalize != nil && !(c.Finalize).ValidCanoto() {
		return false
	}
	if c.Finalization != nil && !(c.Finalization).ValidCanoto() {
		return false
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to call this function concurrently.
func (c *Message) CalculateCanotoCache() {
	if c == nil {
		return
	}
	c.canotoData.messageOneOf = 0
	c.canotoData.size = 0
	if c.Proposal != nil {
		(c.Proposal).CalculateCanotoCache()
		if fieldSize := (c.Proposal).CachedCanotoSize(); fieldSize != 0 {
			c.canotoData.size += len(canoto__Message__Proposal__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
		c.canotoData.messageOneOf = 1
		}
	}
	if c.Vote != nil {
		(c.Vote).CalculateCanotoCache()
		if fieldSize := (c.Vote).CachedCanotoSize(); fieldSize != 0 {
			c.canotoData.size += len(canoto__Message__Vote__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
		c.canotoData.messageOneOf = 2
		}
	}
	if c.Notarization != nil {
		(c.Notarization).CalculateCanotoCache()
		if fieldSize := (c.Notarization).CachedCanotoSize(); fieldSize != 0 {
			c.canotoData.size += len(canoto__Message__Notarization__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
		c.canotoData.messageOneOf = 3
		}
	}
	if c.Finalize != nil {
		(c.Finalize).CalculateCanotoCache()
		if fieldSize := (c.Finalize).CachedCanotoSize(); fieldSize != 0 {
			c.canotoData.size += len(canoto__Message__Finalize__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
		c.canotoData.messageOneOf = 4
		}
	}
	if c.Finalization != nil {
		(c.Finalization).CalculateCanotoCache()
		if fieldSize := (c.Finalization).CachedCanotoSize(); fieldSize != 0 {
			c.canotoData.size += len(canoto__Message__Finalization__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
		c.canotoData.messageOneOf = 5
		}
	}
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *Message) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return c.canotoData.size
}

// CachedWhichOneOfmessage returns the previously calculated field number used
// to represent message.
//
// This field is cached by UnmarshalCanoto, UnmarshalCanotoFrom, and
// CalculateCanotoCache.
//
// If the field has not yet been cached, it will return 0.
//
// If the struct has been modified since the field was last cached, the returned
// field number may be incorrect.
func (c *Message) CachedWhichOneOfmessage() uint32 {
	return c.canotoData.messageOneOf
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *Message) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *Message) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if c.Proposal != nil {
		if fieldSize := (c.Proposal).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__Message__Proposal__tag)
			canoto.AppendInt(&w, int64(fieldSize))
			w = (c.Proposal).MarshalCanotoInto(w)
		}
	}
	if c.Vote != nil {
		if fieldSize := (c.Vote).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__Message__Vote__tag)
			canoto.AppendInt(&w, int64(fieldSize))
			w = (c.Vote).MarshalCanotoInto(w)
		}
	}
	if c.Notarization != nil {
		if fieldSize := (c.Notarization).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__Message__Notarization__tag)
			canoto.AppendInt(&w, int64(fieldSize))
			w = (c.Notarization).MarshalCanotoInto(w)
		}
	}
	if c.Finalize != nil {
		if fieldSize := (c.Finalize).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__Message__Finalize__tag)
			canoto.AppendInt(&w, int64(fieldSize))
			w = (c.Finalize).MarshalCanotoInto(w)
		}
	}
	if c.Finalization != nil {
		if fieldSize := (c.Finalization).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__Message__Finalization__tag)
			canoto.AppendInt(&w, int64(fieldSize))
			w = (c.Finalization).MarshalCanotoInto(w)
		}
	}
	return w
}

const (
	canoto__BlockMessage__Vote__tag = "\x12" // canoto.Tag(2, canoto.Len)
)

type canotoData_BlockMessage struct {
	size int
}

// MakeCanoto creates a new empty value.
func (*BlockMessage) MakeCanoto() *BlockMessage {
	return new(BlockMessage)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// OneOf fields are cached during the unmarshaling process.
//
// The struct is not cleared before unmarshaling, any fields not present in the
// bytes will retain their previous values. If a OneOf field was previously
// cached as being set, attempting to unmarshal that OneOf again will return
// canoto.ErrDuplicateOneOf.
func (c *BlockMessage) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// OneOf fields are cached during the unmarshaling process.
//
// The struct is not cleared before unmarshaling, any fields not present in the
// bytes will retain their previous values. If a OneOf field was previously
// cached as being set, attempting to unmarshal that OneOf again will return
// canoto.ErrDuplicateOneOf.
//
// This function enables configuration of reader options.
func (c *BlockMessage) UnmarshalCanotoFrom(r canoto.Reader) error {
	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 2:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			err := canoto.ReadBytes(&r, &msgBytes)
			r.Unsafe = originalUnsafe
			if err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}

			remainingBytes := r.B
			r.B = msgBytes
			err = (&c.Vote).UnmarshalCanotoFrom(r)
			r.B = remainingBytes
			if err != nil {
				return err
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *BlockMessage) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if !(&c.Vote).ValidCanoto() {
		return false
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to call this function concurrently.
func (c *BlockMessage) CalculateCanotoCache() {
	if c == nil {
		return
	}
	c.canotoData.size = 0
	(&c.Vote).CalculateCanotoCache()
	if fieldSize := (&c.Vote).CachedCanotoSize(); fieldSize != 0 {
		c.canotoData.size += len(canoto__BlockMessage__Vote__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *BlockMessage) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return c.canotoData.size
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *BlockMessage) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *BlockMessage) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if fieldSize := (&c.Vote).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__BlockMessage__Vote__tag)
		canoto.AppendInt(&w, int64(fieldSize))
		w = (&c.Vote).MarshalCanotoInto(w)
	}
	return w
}

const (
	canoto__Vote__Vote__tag      = "\x0a" // canoto.Tag(1, canoto.Len)
	canoto__Vote__Signature__tag = "\x12" // canoto.Tag(2, canoto.Len)
)

type canotoData_Vote struct {
	size int
}

// MakeCanoto creates a new empty value.
func (*Vote) MakeCanoto() *Vote {
	return new(Vote)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// OneOf fields are cached during the unmarshaling process.
//
// The struct is not cleared before unmarshaling, any fields not present in the
// bytes will retain their previous values. If a OneOf field was previously
// cached as being set, attempting to unmarshal that OneOf again will return
// canoto.ErrDuplicateOneOf.
func (c *Vote) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// OneOf fields are cached during the unmarshaling process.
//
// The struct is not cleared before unmarshaling, any fields not present in the
// bytes will retain their previous values. If a OneOf field was previously
// cached as being set, attempting to unmarshal that OneOf again will return
// canoto.ErrDuplicateOneOf.
//
// This function enables configuration of reader options.
func (c *Vote) UnmarshalCanotoFrom(r canoto.Reader) error {
	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			err := canoto.ReadBytes(&r, &msgBytes)
			r.Unsafe = originalUnsafe
			if err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}

			remainingBytes := r.B
			r.B = msgBytes
			err = (&c.Vote).UnmarshalCanotoFrom(r)
			r.B = remainingBytes
			if err != nil {
				return err
			}
		case 2:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			err := canoto.ReadBytes(&r, &msgBytes)
			r.Unsafe = originalUnsafe
			if err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}

			remainingBytes := r.B
			r.B = msgBytes
			err = (&c.Signature).UnmarshalCanotoFrom(r)
			r.B = remainingBytes
			if err != nil {
				return err
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *Vote) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if !(&c.Vote).ValidCanoto() {
		return false
	}
	if !(&c.Signature).ValidCanoto() {
		return false
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to call this function concurrently.
func (c *Vote) CalculateCanotoCache() {
	if c == nil {
		return
	}
	c.canotoData.size = 0
	(&c.Vote).CalculateCanotoCache()
	if fieldSize := (&c.Vote).CachedCanotoSize(); fieldSize != 0 {
		c.canotoData.size += len(canoto__Vote__Vote__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
	(&c.Signature).CalculateCanotoCache()
	if fieldSize := (&c.Signature).CachedCanotoSize(); fieldSize != 0 {
		c.canotoData.size += len(canoto__Vote__Signature__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *Vote) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return c.canotoData.size
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *Vote) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *Vote) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if fieldSize := (&c.Vote).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Vote__Vote__tag)
		canoto.AppendInt(&w, int64(fieldSize))
		w = (&c.Vote).MarshalCanotoInto(w)
	}
	if fieldSize := (&c.Signature).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Vote__Signature__tag)
		canoto.AppendInt(&w, int64(fieldSize))
		w = (&c.Signature).MarshalCanotoInto(w)
	}
	return w
}

const (
	canoto__Notarization__Vote__tag = "\x0a" // canoto.Tag(1, canoto.Len)
)

type canotoData_Notarization struct {
	size int
}

// MakeCanoto creates a new empty value.
func (*Notarization) MakeCanoto() *Notarization {
	return new(Notarization)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// OneOf fields are cached during the unmarshaling process.
//
// The struct is not cleared before unmarshaling, any fields not present in the
// bytes will retain their previous values. If a OneOf field was previously
// cached as being set, attempting to unmarshal that OneOf again will return
// canoto.ErrDuplicateOneOf.
func (c *Notarization) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// OneOf fields are cached during the unmarshaling process.
//
// The struct is not cleared before unmarshaling, any fields not present in the
// bytes will retain their previous values. If a OneOf field was previously
// cached as being set, attempting to unmarshal that OneOf again will return
// canoto.ErrDuplicateOneOf.
//
// This function enables configuration of reader options.
func (c *Notarization) UnmarshalCanotoFrom(r canoto.Reader) error {
	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			err := canoto.ReadBytes(&r, &msgBytes)
			r.Unsafe = originalUnsafe
			if err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}

			remainingBytes := r.B
			r.B = msgBytes
			err = (&c.Vote).UnmarshalCanotoFrom(r)
			r.B = remainingBytes
			if err != nil {
				return err
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *Notarization) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if !(&c.Vote).ValidCanoto() {
		return false
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to call this function concurrently.
func (c *Notarization) CalculateCanotoCache() {
	if c == nil {
		return
	}
	c.canotoData.size = 0
	(&c.Vote).CalculateCanotoCache()
	if fieldSize := (&c.Vote).CachedCanotoSize(); fieldSize != 0 {
		c.canotoData.size += len(canoto__Notarization__Vote__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *Notarization) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return c.canotoData.size
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *Notarization) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *Notarization) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if fieldSize := (&c.Vote).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Notarization__Vote__tag)
		canoto.AppendInt(&w, int64(fieldSize))
		w = (&c.Vote).MarshalCanotoInto(w)
	}
	return w
}

const (
	canoto__Finalization__Finalization__tag = "\x0a" // canoto.Tag(1, canoto.Len)
	canoto__Finalization__Signature__tag    = "\x12" // canoto.Tag(2, canoto.Len)
)

type canotoData_Finalization struct {
	size int
}

// MakeCanoto creates a new empty value.
func (*Finalization) MakeCanoto() *Finalization {
	return new(Finalization)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// OneOf fields are cached during the unmarshaling process.
//
// The struct is not cleared before unmarshaling, any fields not present in the
// bytes will retain their previous values. If a OneOf field was previously
// cached as being set, attempting to unmarshal that OneOf again will return
// canoto.ErrDuplicateOneOf.
func (c *Finalization) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// OneOf fields are cached during the unmarshaling process.
//
// The struct is not cleared before unmarshaling, any fields not present in the
// bytes will retain their previous values. If a OneOf field was previously
// cached as being set, attempting to unmarshal that OneOf again will return
// canoto.ErrDuplicateOneOf.
//
// This function enables configuration of reader options.
func (c *Finalization) UnmarshalCanotoFrom(r canoto.Reader) error {
	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			err := canoto.ReadBytes(&r, &msgBytes)
			r.Unsafe = originalUnsafe
			if err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}

			remainingBytes := r.B
			r.B = msgBytes
			err = (&c.Finalization).UnmarshalCanotoFrom(r)
			r.B = remainingBytes
			if err != nil {
				return err
			}
		case 2:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			err := canoto.ReadBytes(&r, &msgBytes)
			r.Unsafe = originalUnsafe
			if err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}

			remainingBytes := r.B
			r.B = msgBytes
			err = (&c.Signature).UnmarshalCanotoFrom(r)
			r.B = remainingBytes
			if err != nil {
				return err
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *Finalization) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if !(&c.Finalization).ValidCanoto() {
		return false
	}
	if !(&c.Signature).ValidCanoto() {
		return false
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to call this function concurrently.
func (c *Finalization) CalculateCanotoCache() {
	if c == nil {
		return
	}
	c.canotoData.size = 0
	(&c.Finalization).CalculateCanotoCache()
	if fieldSize := (&c.Finalization).CachedCanotoSize(); fieldSize != 0 {
		c.canotoData.size += len(canoto__Finalization__Finalization__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
	(&c.Signature).CalculateCanotoCache()
	if fieldSize := (&c.Signature).CachedCanotoSize(); fieldSize != 0 {
		c.canotoData.size += len(canoto__Finalization__Signature__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *Finalization) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return c.canotoData.size
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *Finalization) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *Finalization) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if fieldSize := (&c.Finalization).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Finalization__Finalization__tag)
		canoto.AppendInt(&w, int64(fieldSize))
		w = (&c.Finalization).MarshalCanotoInto(w)
	}
	if fieldSize := (&c.Signature).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Finalization__Signature__tag)
		canoto.AppendInt(&w, int64(fieldSize))
		w = (&c.Signature).MarshalCanotoInto(w)
	}
	return w
}

const (
	canoto__FinalizationCertificate__Finalization__tag = "\x0a" // canoto.Tag(1, canoto.Len)
)

type canotoData_FinalizationCertificate struct {
	size int
}

// MakeCanoto creates a new empty value.
func (*FinalizationCertificate) MakeCanoto() *FinalizationCertificate {
	return new(FinalizationCertificate)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// OneOf fields are cached during the unmarshaling process.
//
// The struct is not cleared before unmarshaling, any fields not present in the
// bytes will retain their previous values. If a OneOf field was previously
// cached as being set, attempting to unmarshal that OneOf again will return
// canoto.ErrDuplicateOneOf.
func (c *FinalizationCertificate) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// OneOf fields are cached during the unmarshaling process.
//
// The struct is not cleared before unmarshaling, any fields not present in the
// bytes will retain their previous values. If a OneOf field was previously
// cached as being set, attempting to unmarshal that OneOf again will return
// canoto.ErrDuplicateOneOf.
//
// This function enables configuration of reader options.
func (c *FinalizationCertificate) UnmarshalCanotoFrom(r canoto.Reader) error {
	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			err := canoto.ReadBytes(&r, &msgBytes)
			r.Unsafe = originalUnsafe
			if err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}

			remainingBytes := r.B
			r.B = msgBytes
			err = (&c.Finalization).UnmarshalCanotoFrom(r)
			r.B = remainingBytes
			if err != nil {
				return err
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *FinalizationCertificate) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if !(&c.Finalization).ValidCanoto() {
		return false
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to call this function concurrently.
func (c *FinalizationCertificate) CalculateCanotoCache() {
	if c == nil {
		return
	}
	c.canotoData.size = 0
	(&c.Finalization).CalculateCanotoCache()
	if fieldSize := (&c.Finalization).CachedCanotoSize(); fieldSize != 0 {
		c.canotoData.size += len(canoto__FinalizationCertificate__Finalization__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *FinalizationCertificate) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return c.canotoData.size
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *FinalizationCertificate) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *FinalizationCertificate) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if fieldSize := (&c.Finalization).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__FinalizationCertificate__Finalization__tag)
		canoto.AppendInt(&w, int64(fieldSize))
		w = (&c.Finalization).MarshalCanotoInto(w)
	}
	return w
}

const (
	canoto__SignedMessage__Payload__tag = "\x0a" // canoto.Tag(1, canoto.Len)
	canoto__SignedMessage__Context__tag = "\x12" // canoto.Tag(2, canoto.Len)
)

type canotoData_SignedMessage struct {
	size int
}

// MakeCanoto creates a new empty value.
func (*SignedMessage) MakeCanoto() *SignedMessage {
	return new(SignedMessage)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// OneOf fields are cached during the unmarshaling process.
//
// The struct is not cleared before unmarshaling, any fields not present in the
// bytes will retain their previous values. If a OneOf field was previously
// cached as being set, attempting to unmarshal that OneOf again will return
// canoto.ErrDuplicateOneOf.
func (c *SignedMessage) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// OneOf fields are cached during the unmarshaling process.
//
// The struct is not cleared before unmarshaling, any fields not present in the
// bytes will retain their previous values. If a OneOf field was previously
// cached as being set, attempting to unmarshal that OneOf again will return
// canoto.ErrDuplicateOneOf.
//
// This function enables configuration of reader options.
func (c *SignedMessage) UnmarshalCanotoFrom(r canoto.Reader) error {
	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadBytes(&r, &c.Payload); err != nil {
				return err
			}
			if len(c.Payload) == 0 {
				return canoto.ErrZeroValue
			}
		case 2:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadString(&r, &c.Context); err != nil {
				return err
			}
			if len(c.Context) == 0 {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *SignedMessage) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if !utf8.ValidString(string(c.Context)) {
		return false
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to call this function concurrently.
func (c *SignedMessage) CalculateCanotoCache() {
	if c == nil {
		return
	}
	c.canotoData.size = 0
	if len(c.Payload) != 0 {
		c.canotoData.size += len(canoto__SignedMessage__Payload__tag) + canoto.SizeBytes(c.Payload)
	}
	if len(c.Context) != 0 {
		c.canotoData.size += len(canoto__SignedMessage__Context__tag) + canoto.SizeBytes(c.Context)
	}
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *SignedMessage) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return c.canotoData.size
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *SignedMessage) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *SignedMessage) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if len(c.Payload) != 0 {
		canoto.Append(&w, canoto__SignedMessage__Payload__tag)
		canoto.AppendBytes(&w, c.Payload)
	}
	if len(c.Context) != 0 {
		canoto.Append(&w, canoto__SignedMessage__Context__tag)
		canoto.AppendBytes(&w, c.Context)
	}
	return w
}

const (
	canoto__Signature__Signer__tag = "\x0a" // canoto.Tag(1, canoto.Len)
	canoto__Signature__Value__tag  = "\x12" // canoto.Tag(2, canoto.Len)
)

type canotoData_Signature struct {
	size int
}

// MakeCanoto creates a new empty value.
func (*Signature) MakeCanoto() *Signature {
	return new(Signature)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// OneOf fields are cached during the unmarshaling process.
//
// The struct is not cleared before unmarshaling, any fields not present in the
// bytes will retain their previous values. If a OneOf field was previously
// cached as being set, attempting to unmarshal that OneOf again will return
// canoto.ErrDuplicateOneOf.
func (c *Signature) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// OneOf fields are cached during the unmarshaling process.
//
// The struct is not cleared before unmarshaling, any fields not present in the
// bytes will retain their previous values. If a OneOf field was previously
// cached as being set, attempting to unmarshal that OneOf again will return
// canoto.ErrDuplicateOneOf.
//
// This function enables configuration of reader options.
func (c *Signature) UnmarshalCanotoFrom(r canoto.Reader) error {
	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadBytes(&r, &c.Signer); err != nil {
				return err
			}
			if len(c.Signer) == 0 {
				return canoto.ErrZeroValue
			}
		case 2:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadBytes(&r, &c.Value); err != nil {
				return err
			}
			if len(c.Value) == 0 {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *Signature) ValidCanoto() bool {
	if c == nil {
		return true
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to call this function concurrently.
func (c *Signature) CalculateCanotoCache() {
	if c == nil {
		return
	}
	c.canotoData.size = 0
	if len(c.Signer) != 0 {
		c.canotoData.size += len(canoto__Signature__Signer__tag) + canoto.SizeBytes(c.Signer)
	}
	if len(c.Value) != 0 {
		c.canotoData.size += len(canoto__Signature__Value__tag) + canoto.SizeBytes(c.Value)
	}
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *Signature) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return c.canotoData.size
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *Signature) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *Signature) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if len(c.Signer) != 0 {
		canoto.Append(&w, canoto__Signature__Signer__tag)
		canoto.AppendBytes(&w, c.Signer)
	}
	if len(c.Value) != 0 {
		canoto.Append(&w, canoto__Signature__Value__tag)
		canoto.AppendBytes(&w, c.Value)
	}
	return w
}

const (
	canoto__BlockHeader__ProtocolMetadata__tag = "\x0a" // canoto.Tag(1, canoto.Len)
	canoto__BlockHeader__Digest__tag           = "\x12" // canoto.Tag(2, canoto.Len)
)

type canotoData_BlockHeader struct {
	size int
}

// MakeCanoto creates a new empty value.
func (*BlockHeader) MakeCanoto() *BlockHeader {
	return new(BlockHeader)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// OneOf fields are cached during the unmarshaling process.
//
// The struct is not cleared before unmarshaling, any fields not present in the
// bytes will retain their previous values. If a OneOf field was previously
// cached as being set, attempting to unmarshal that OneOf again will return
// canoto.ErrDuplicateOneOf.
func (c *BlockHeader) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// OneOf fields are cached during the unmarshaling process.
//
// The struct is not cleared before unmarshaling, any fields not present in the
// bytes will retain their previous values. If a OneOf field was previously
// cached as being set, attempting to unmarshal that OneOf again will return
// canoto.ErrDuplicateOneOf.
//
// This function enables configuration of reader options.
func (c *BlockHeader) UnmarshalCanotoFrom(r canoto.Reader) error {
	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			err := canoto.ReadBytes(&r, &msgBytes)
			r.Unsafe = originalUnsafe
			if err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}

			remainingBytes := r.B
			r.B = msgBytes
			err = (&c.ProtocolMetadata).UnmarshalCanotoFrom(r)
			r.B = remainingBytes
			if err != nil {
				return err
			}
		case 2:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			var length int64
			if err := canoto.ReadInt(&r, &length); err != nil {
				return err
			}

			const (
				expectedLength      = len(c.Digest)
				expectedLengthInt64 = int64(expectedLength)
			)
			if length != expectedLengthInt64 {
				return canoto.ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			copy(c.Digest[:], r.B)
			if canoto.IsZero(c.Digest) {
				return canoto.ErrZeroValue
			}
			r.B = r.B[expectedLength:]
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *BlockHeader) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if !(&c.ProtocolMetadata).ValidCanoto() {
		return false
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to call this function concurrently.
func (c *BlockHeader) CalculateCanotoCache() {
	if c == nil {
		return
	}
	c.canotoData.size = 0
	(&c.ProtocolMetadata).CalculateCanotoCache()
	if fieldSize := (&c.ProtocolMetadata).CachedCanotoSize(); fieldSize != 0 {
		c.canotoData.size += len(canoto__BlockHeader__ProtocolMetadata__tag) + canoto.SizeInt(int64(fieldSize)) + fieldSize
	}
	if !canoto.IsZero(c.Digest) {
		c.canotoData.size += len(canoto__BlockHeader__Digest__tag) + canoto.SizeBytes(c.Digest[:])
	}
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *BlockHeader) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return c.canotoData.size
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *BlockHeader) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *BlockHeader) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if fieldSize := (&c.ProtocolMetadata).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__BlockHeader__ProtocolMetadata__tag)
		canoto.AppendInt(&w, int64(fieldSize))
		w = (&c.ProtocolMetadata).MarshalCanotoInto(w)
	}
	if !canoto.IsZero(c.Digest) {
		canoto.Append(&w, canoto__BlockHeader__Digest__tag)
		canoto.AppendBytes(&w, c.Digest[:])
	}
	return w
}

const (
	canoto__ProtocolMetadata__Epoch__tag = "\x08" // canoto.Tag(1, canoto.Varint)
	canoto__ProtocolMetadata__Round__tag = "\x10" // canoto.Tag(2, canoto.Varint)
	canoto__ProtocolMetadata__Seq__tag   = "\x18" // canoto.Tag(3, canoto.Varint)
	canoto__ProtocolMetadata__Prev__tag  = "\x22" // canoto.Tag(4, canoto.Len)
)

type canotoData_ProtocolMetadata struct {
	size int
}

// MakeCanoto creates a new empty value.
func (*ProtocolMetadata) MakeCanoto() *ProtocolMetadata {
	return new(ProtocolMetadata)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// OneOf fields are cached during the unmarshaling process.
//
// The struct is not cleared before unmarshaling, any fields not present in the
// bytes will retain their previous values. If a OneOf field was previously
// cached as being set, attempting to unmarshal that OneOf again will return
// canoto.ErrDuplicateOneOf.
func (c *ProtocolMetadata) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// OneOf fields are cached during the unmarshaling process.
//
// The struct is not cleared before unmarshaling, any fields not present in the
// bytes will retain their previous values. If a OneOf field was previously
// cached as being set, attempting to unmarshal that OneOf again will return
// canoto.ErrDuplicateOneOf.
//
// This function enables configuration of reader options.
func (c *ProtocolMetadata) UnmarshalCanotoFrom(r canoto.Reader) error {
	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.Epoch); err != nil {
				return err
			}
			if canoto.IsZero(c.Epoch) {
				return canoto.ErrZeroValue
			}
		case 2:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.Round); err != nil {
				return err
			}
			if canoto.IsZero(c.Round) {
				return canoto.ErrZeroValue
			}
		case 3:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.Seq); err != nil {
				return err
			}
			if canoto.IsZero(c.Seq) {
				return canoto.ErrZeroValue
			}
		case 4:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			var length int64
			if err := canoto.ReadInt(&r, &length); err != nil {
				return err
			}

			const (
				expectedLength      = len(c.Prev)
				expectedLengthInt64 = int64(expectedLength)
			)
			if length != expectedLengthInt64 {
				return canoto.ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			copy(c.Prev[:], r.B)
			if canoto.IsZero(c.Prev) {
				return canoto.ErrZeroValue
			}
			r.B = r.B[expectedLength:]
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *ProtocolMetadata) ValidCanoto() bool {
	if c == nil {
		return true
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to call this function concurrently.
func (c *ProtocolMetadata) CalculateCanotoCache() {
	if c == nil {
		return
	}
	c.canotoData.size = 0
	if !canoto.IsZero(c.Epoch) {
		c.canotoData.size += len(canoto__ProtocolMetadata__Epoch__tag) + canoto.SizeInt(c.Epoch)
	}
	if !canoto.IsZero(c.Round) {
		c.canotoData.size += len(canoto__ProtocolMetadata__Round__tag) + canoto.SizeInt(c.Round)
	}
	if !canoto.IsZero(c.Seq) {
		c.canotoData.size += len(canoto__ProtocolMetadata__Seq__tag) + canoto.SizeInt(c.Seq)
	}
	if !canoto.IsZero(c.Prev) {
		c.canotoData.size += len(canoto__ProtocolMetadata__Prev__tag) + canoto.SizeBytes(c.Prev[:])
	}
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *ProtocolMetadata) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return c.canotoData.size
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *ProtocolMetadata) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to call this function concurrently.
func (c *ProtocolMetadata) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if !canoto.IsZero(c.Epoch) {
		canoto.Append(&w, canoto__ProtocolMetadata__Epoch__tag)
		canoto.AppendInt(&w, c.Epoch)
	}
	if !canoto.IsZero(c.Round) {
		canoto.Append(&w, canoto__ProtocolMetadata__Round__tag)
		canoto.AppendInt(&w, c.Round)
	}
	if !canoto.IsZero(c.Seq) {
		canoto.Append(&w, canoto__ProtocolMetadata__Seq__tag)
		canoto.AppendInt(&w, c.Seq)
	}
	if !canoto.IsZero(c.Prev) {
		canoto.Append(&w, canoto__ProtocolMetadata__Prev__tag)
		canoto.AppendBytes(&w, c.Prev[:])
	}
	return w
}
